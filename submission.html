
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>GSoC 2022 - Expanding FEniCSx electromagnetic demos &#8212; GSoC 2022 - Expanding FEniCSx electromagnetic demos</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Scattering from a wire with scattering boundary conditions" href="chapter1/demo_scattering_boundary_conditions.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">GSoC 2022 - Expanding FEniCSx electromagnetic demos</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1 current active">
                <a class="reference internal" href="#">
                    GSoC 2022 - Expanding FEniCSx electromagnetic demos
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Scattering boundary conditions
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter1/demo_scattering_boundary_conditions.html">
   Scattering from a wire with scattering boundary conditions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter1/analytical_efficiencies_wire.html">
   Calculation of analytical efficiencies
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Perfectly matched layer (PML)
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter2/demo_pml.html">
   Scattering from a wire with perfectly matched layer condition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter2/analytical_efficiencies_wire.html">
   Calculation of analytical efficiencies
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Half-loaded waveguide
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter3/demo_half_loaded_waveguide.html">
   Mode analysis for a half-loaded rectangular waveguide
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter3/analytical_modes.html">
   Analytical solutions for the half-loaded waveguide
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Axisymmetric Maxwell's equations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter4/demo_axis.html">
   Scattering from a sphere in the axisymmetric formulation
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/mikics/gsoc-jupyterbook"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/mikics/gsoc-jupyterbook/issues/new?title=Issue%20on%20page%20%2Fsubmission.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/mikics/gsoc-jupyterbook/edit/main/./submission.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/submission.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-contributions">
   List of contributions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pull-requests">
     Pull Requests
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#issues">
     Issues
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#whats-next">
     What’s next
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#highlights-of-the-demos">
   Highlights of the demos
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-1-scattering-boundary-conditions">
     Demo #1: Scattering Boundary Conditions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-2-perfectly-matched-layers">
     Demo #2: Perfectly Matched Layers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-3-half-loaded-waveguide-with-slepc">
     Demo #3: Half-loaded waveguide with SLEPc
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-4-maxwells-equations-for-axisymmetric-geometries">
     Demo #4: Maxwell’s equations for axisymmetric geometries
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#nabla-times-operator-in-cylindrical-coordinates">
       <span class="math notranslate nohighlight">
        \(\nabla\times\)
       </span>
       operator in cylindrical coordinates
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cylindrical-harmonic-expansion-for-mathbf-e-m-b">
       Cylindrical harmonic expansion for
       <span class="math notranslate nohighlight">
        \(\mathbf{E}^{(m)}_b\)
       </span>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#axisymmetric-pmls">
       Axisymmetric PMLs
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#solving-the-problem">
       Solving the problem
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#test">
       Test
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#challenges-and-final-remarks">
   Challenges and final remarks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#contacts">
   Contacts
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#contents">
   Contents
  </a>
  <ul class="nav section-nav flex-column">
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>GSoC 2022 - Expanding FEniCSx electromagnetic demos</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-contributions">
   List of contributions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pull-requests">
     Pull Requests
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#issues">
     Issues
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#whats-next">
     What’s next
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#highlights-of-the-demos">
   Highlights of the demos
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-1-scattering-boundary-conditions">
     Demo #1: Scattering Boundary Conditions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-2-perfectly-matched-layers">
     Demo #2: Perfectly Matched Layers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-3-half-loaded-waveguide-with-slepc">
     Demo #3: Half-loaded waveguide with SLEPc
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#demo-4-maxwells-equations-for-axisymmetric-geometries">
     Demo #4: Maxwell’s equations for axisymmetric geometries
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#nabla-times-operator-in-cylindrical-coordinates">
       <span class="math notranslate nohighlight">
        \(\nabla\times\)
       </span>
       operator in cylindrical coordinates
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cylindrical-harmonic-expansion-for-mathbf-e-m-b">
       Cylindrical harmonic expansion for
       <span class="math notranslate nohighlight">
        \(\mathbf{E}^{(m)}_b\)
       </span>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#axisymmetric-pmls">
       Axisymmetric PMLs
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#solving-the-problem">
       Solving the problem
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#test">
       Test
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#challenges-and-final-remarks">
   Challenges and final remarks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#contacts">
   Contacts
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#contents">
   Contents
  </a>
  <ul class="nav section-nav flex-column">
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="gsoc-2022-expanding-fenicsx-electromagnetic-demos">
<h1>GSoC 2022 - Expanding FEniCSx electromagnetic demos<a class="headerlink" href="#gsoc-2022-expanding-fenicsx-electromagnetic-demos" title="Permalink to this headline">#</a></h1>
<p>In this website, I will provide an overview of my work as a GSoC 2022 contributor for
the <a class="reference external" href="https://fenicsproject.org/">FEniCS project</a> (sponsored by <a class="reference external" href="https://numfocus.org/">NumFOCUS</a>)
and its main repository <a class="reference external" href="https://github.com/FEniCS/dolfinx">DOLFINx</a>.
The goal of the project was to expand DOLFINx electromagnetic demos, in order to
promote the use of the FEniCSx environment for solving electromagnetic and photonic
problems. During GSoC 2022, I have developed demos showing how to:</p>
<ul class="simple">
<li><p>implement scattering boundary conditions;</p></li>
<li><p>implement perfectly matched layers;</p></li>
<li><p>solve electromagnetic eigenvalue problems;</p></li>
<li><p>solve 3D electromagnetic problems for axisymmetric structures.</p></li>
</ul>
<p>All the problems are solved within the time-harmonic approximation for simple
geometries, but can be easily generalized to more complicated study cases.
The documentation for the demos has been provided under the form of Python
comments that can be visualized as text and math formula in <a class="reference external" href="https://jupyter.org/">Jupyter notebook</a>
by converting the <code class="docutils literal notranslate"><span class="pre">.py</span></code> files with <a class="reference external" href="https://jupytext.readthedocs.io/en/latest/install.html">Jupytext</a>. Besides,
each demo contains tests for comparing the DOLFINx outputs with the analytical results
for each problem.</p>
<p>This website has been built with <a class="reference external" href="https://jupyterbook.org/en/stable/intro.html">Jupyter book</a>, and on the left-hand side you can find
the Jupyter notebooks of the demos I developed. In this way, you can directly
visualize the mathematical documentation in the demos, the code, the outputs, and
you can play with the settings by using Binder (just click on the <i class="fa fa-rocket"></i> icon).</p>
<p>With respect to the original plan, we have not developed the demo showing how to
handle complex numbers in DOLFINx, and the demo showing how to use the <code class="docutils literal notranslate"><span class="pre">MPI.COMM_SELF</span></code>
communicator. In the first case, the demo was considered unnecessary, since all the
main features of complex numbers in DOLFINx naturally arises in all electromagnetic demos, which
widely implement them. In the second case, the demo was substituted with the eigenvalue
demo, which was not planned at first. However, I plan to work on the <code class="docutils literal notranslate"><span class="pre">MPI.COMM_SELF</span></code> demo
in the weeks following the end of GSoC 2022.</p>
<p>In my opinion, the original goal has been successfully reached. Indeed, even if many pull
requests are still open, the main work for the demos have been done, and they just need
to pass the final rounds of reviews by FEniCSx reviewers to be finally merged into
the <code class="docutils literal notranslate"><span class="pre">main</span></code> DOLFINx branch.</p>
<section id="list-of-contributions">
<h2>List of contributions<a class="headerlink" href="#list-of-contributions" title="Permalink to this headline">#</a></h2>
<section id="pull-requests">
<h3>Pull Requests<a class="headerlink" href="#pull-requests" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2237">PR #2237</a> (<strong>merged</strong>): this pull request
adds the demo showing how to set a time-harmonic electromagnetic problem
with scattering boundary conditions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">demo_scattering_boundary_conditions.py</span></code>: solves the time-harmonic problem
of a TM-polarized plane wave scattered by a gold wire using
scattering boundary conditions;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mesh_wire.py</span></code>: generates the mesh for the demo;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">analytical_efficiencies_wire.py</span></code>: calculates the analytical efficiencies
for a wire;</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2276">PR #2276</a> (<strong>merged</strong>): this pull request
adds the demo showing how to set a time-harmonic electromagnetic problem with perfectly matched layers:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">demo_pml.py</span></code>: solves the time-harmonic problem of a TM-polarized plane wave scattered by a gold wire using perfectly matched layers;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mesh_wire_pml.py</span></code>: generates the mesh for the demo;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">analytical_efficiencies_wire.py</span></code>: calculates the analytical efficiencies
for a wire;</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2338">PR #2338</a> (<strong>merged</strong>): this pull request adds
the demo showing how to solve a time-harmonic electromagnetic eigenvalue problem with DOLFINx and SLEPc:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">demo_waveguide.py</span></code>: solves the eigenvalue problem associated with an electromagnetic half-loaded
waveguide with SLEPc;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">analytical_modes.py</span></code>: verifies if FEniCSx modes are consistent with the equations
for the analytical modes;</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2339">PR #2339</a> (<strong>merged</strong>): this pull request adds the demo
showing how to solve a time-harmonic electromagnetic problem for an axisymmetric geometry:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">demo_axis.py</span></code>: solves the time-harmonic problem of a plane wave scattered by a sphere
within the axisymmetric approximation, using perfectly matched layers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mesh_sphere_axis.py</span></code>: generates the mesh for the demo</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2357">PR #2357</a> (<strong>merged</strong>): this pull request adds the line
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">dolfinx.io</span> <span class="pre">import</span> <span class="pre">gmshio</span></code> in <code class="docutils literal notranslate"><span class="pre">python/io/__init__.py</span></code> so that <code class="docutils literal notranslate"><span class="pre">gmshio</span></code> is considered a module
in DOLFINx. Besides, it also removes an unnecessary <code class="docutils literal notranslate"><span class="pre">gmshio</span></code> string in the <code class="docutils literal notranslate"><span class="pre">has_adios2</span></code> conditional
block.</p></li>
</ul>
</section>
<section id="issues">
<h3>Issues<a class="headerlink" href="#issues" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/FEniCS/dolfinx/issues/2343">GH issue #2343</a> (<strong>closed as completed</strong>): issue
showing an inconsistency when solving problems with <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code> having <code class="docutils literal notranslate"><span class="pre">Lagrange</span></code> elements. This
issue arose during the writing for <a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2339">PR #2339</a>, when
I noticed different DOLFINx outputs when changing the <code class="docutils literal notranslate"><span class="pre">degree</span></code> of <code class="docutils literal notranslate"><span class="pre">Lagrange</span></code> elements. The root of
this issue was a wrong permutation inside <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code>, which was then fixed by <a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2347">PR #2347</a>.</p></li>
</ul>
</section>
<section id="whats-next">
<h3>What’s next<a class="headerlink" href="#whats-next" title="Permalink to this headline">#</a></h3>
<p>The plan after the end of the Google Summer of Code is the following:</p>
<ul class="simple">
<li><p>Work on merging the open pull requests;</p></li>
<li><p>Develop a demo showing how to use the <code class="docutils literal notranslate"><span class="pre">MPI.COMM_SELF</span></code> communicator; this will be
particularly useful when solving parameterized problem as in the axisymmetric case, where
<code class="docutils literal notranslate"><span class="pre">MPI.COMM_SELF</span></code> would allow us to split the multiple harmonic numbers over multiple processors;</p></li>
<li><p>Animate DOLFINx solutions with PyVista;</p></li>
<li><p>Project axisymmetric solutions in 3D using PyVista (e.g. by using <a class="reference external" href="https://docs.pyvista.org/examples/01-filter/extrude-rotate.html">extrude rotation</a>);</p></li>
<li><p>Develop more complicated demos (e.g. demos involving periodic boundary conditions);</p></li>
<li><p>Join more discussions on <a class="reference external" href="https://fenicsproject.discourse.group/">discourse</a>.</p></li>
</ul>
</section>
</section>
<section id="highlights-of-the-demos">
<h2>Highlights of the demos<a class="headerlink" href="#highlights-of-the-demos" title="Permalink to this headline">#</a></h2>
<section id="demo-1-scattering-boundary-conditions">
<h3>Demo #1: Scattering Boundary Conditions<a class="headerlink" href="#demo-1-scattering-boundary-conditions" title="Permalink to this headline">#</a></h3>
<p>This demo shows how to implement scattering boundary conditions for a time-harmonic
electromagnetic problem. In particular, we show how to use scattering boundary
conditions to calculate the scattering of a TM-polarized plane wave from an infinite
gold wire. The demo can also be considered an introductory demo for
electromagnetic problems, since it also shows how to derive the weak
form of the corresponding Maxwell’s equations. Indeed, we start from
these equations (Maxwell’s equations + scattering boundary conditions):</p>
<div class="math notranslate nohighlight">
\[
-\nabla \times \nabla \times \mathbf{E}_s+\varepsilon_{r} k_{0}^{2}
\mathbf{E}_s
+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_{b}\right)
\mathbf{E}_{\mathrm{b}}=0 \textrm{ in } \Omega
\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{n} \times
\nabla \times \mathbf{E}_s+\left(j k_{0}n_b + \frac{1}{2r}
\right) \mathbf{n} \times \mathbf{E}_s
\times \mathbf{n}=0\quad \textrm{ on } \partial \Omega
\]</div>
<p>and show all the steps to arrive at the final weak form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \int_{\Omega}-(\nabla \times \mathbf{E}_s) \cdot (\nabla \times
\bar{\mathbf{v}})+\varepsilon_{r} k_{0}^{2} \mathbf{E}_s \cdot
\bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_b\right)
\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d}x \\ +&amp;\int_{\partial \Omega}
\left(j n_bk_{0}+\frac{1}{2r}\right)( \mathbf{n} \times \mathbf{E}_s \times
\mathbf{n}) \cdot \bar{\mathbf{v}} ~\mathrm{d} s = 0.
\end{align}
\end{split}\]</div>
<p>which we implement in DOLFINx in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dDom</span> \
    <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Es</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span> \
    <span class="o">+</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps</span> <span class="o">-</span> <span class="n">eps_bkg</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Eb</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span> \
    <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span> \
    <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Es_3d</span><span class="p">,</span> <span class="n">n_3d</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v_3d</span><span class="p">,</span> <span class="n">n_3d</span><span class="p">))</span> <span class="o">*</span> <span class="n">dsbc</span>
</pre></div>
</div>
<p>Besides, we also show how to implement the background field <span class="math notranslate nohighlight">\( \mathbf{E}_b = -\sin\theta e^{j (k_xx+k_yy)}\hat{\mathbf{u}}_xv+ \cos\theta e^{j (k_xx+k_yy)}\hat{\mathbf{u}}_y\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BackgroundElectricField</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_b</span><span class="p">,</span> <span class="n">k0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">=</span> <span class="n">n_b</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="n">kx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">ky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">kx</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ky</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">ay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ax</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="n">ay</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">))</span>
</pre></div>
</div>
<p>and how to calculate the efficiencies:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; Q_{abs} = \operatorname{Re}\left(\int_{\Omega_{m}} \frac{1}{2}
\frac{\operatorname{Im}(\varepsilon_m)k_0}{Z_0n_b}
\mathbf{E}\cdot\hat{\mathbf{E}}dx\right) \\
&amp; Q_{sca} = \operatorname{Re}\left(\int_{\partial\Omega} \frac{1}{2}
\left(\mathbf{E}_s\times\bar{\mathbf{H}}_s\right)
\cdot\mathbf{n}ds\right)\\ \\
&amp; Q_{ext} = Q_{abs} + Q_{sca}, \\
&amp; q_{abs} = \frac{Q_{abs}}{I_0\sigma_{gcs}} \\
&amp; q_{sca} = \frac{Q_{sca}}{I_0\sigma_{gcs}} \\
&amp; q_{ext} = q_{abs} + q_{sca}, \\
\end{align}
\end{split}\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu_0</span> <span class="o">/</span> <span class="n">epsilon_0</span><span class="p">)</span>

<span class="c1"># Magnetic field H</span>
<span class="n">Hsh_3d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Esh</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Z0</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span><span class="p">)</span>

<span class="n">Esh_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">Esh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Esh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">E_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Intensity of the electromagnetic fields I0 = 0.5*E0**2/Z0</span>
<span class="c1"># E0 = np.sqrt(ax**2 + ay**2) = 1, see background_electric_field</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">Z0</span>

<span class="c1"># Geometrical cross section of the wire</span>
<span class="n">gcs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_wire</span>

<span class="c1"># Quantities for the calculation of efficiencies</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Esh_3d</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Hsh_3d</span><span class="p">)),</span> <span class="n">n_3d</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">eps_au</span><span class="p">)</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">E_3d</span><span class="p">,</span> <span class="n">E_3d</span><span class="p">))</span> <span class="o">/</span> <span class="n">Z0</span> <span class="o">/</span> <span class="n">n_bkg</span>

<span class="c1"># Define integration domain for the wire</span>
<span class="n">dAu</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">au_tag</span><span class="p">)</span>

<span class="c1"># Normalized absorption efficiency</span>
<span class="n">q_abs_fenics_proc</span> <span class="o">=</span> <span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">Q</span> <span class="o">*</span> <span class="n">dAu</span><span class="p">))</span> <span class="o">/</span> <span class="n">gcs</span> <span class="o">/</span> <span class="n">I0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="c1"># Sum results from all MPI processes</span>
<span class="n">q_abs_fenics</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">q_abs_fenics_proc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

<span class="c1"># Normalized scattering efficiency</span>
<span class="n">q_sca_fenics_proc</span> <span class="o">=</span> <span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">P</span> <span class="o">*</span> <span class="n">dsbc</span><span class="p">))</span> <span class="o">/</span> <span class="n">gcs</span> <span class="o">/</span> <span class="n">I0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

<span class="c1"># Sum results from all MPI processes</span>
<span class="n">q_sca_fenics</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">q_sca_fenics_proc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
</pre></div>
</div>
<p>We compared these efficiencies with analytical ones (by means of a function in <code class="docutils literal notranslate"><span class="pre">analytical_efficiencies_wire.py</span></code>) to test our demo. In the end, we get
an error much smaller than <span class="math notranslate nohighlight">\(1\%\)</span>, as certified by the final output,and
therefore we can say that our demo works correctly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">analytical</span> <span class="n">absorption</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">1.2115253567863489</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">absorption</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">1.210977254477182</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.04524067994918296</span><span class="o">%</span>

<span class="n">The</span> <span class="n">analytical</span> <span class="n">scattering</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.9481819974744393</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">scattering</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.947864860367565</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.033446860172311944</span><span class="o">%</span>

<span class="n">The</span> <span class="n">analytical</span> <span class="n">extinction</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">2.1597073542607883</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">extinction</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">2.158842114844747</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.040062808247346045</span><span class="o">%</span>
</pre></div>
</div>
<p>As a final treat, here below you can see the animation of the DOLFINx solution post-processed in
paraview:</p>
<p><img alt="sbc" src="_images/animation_sbc.gif" /></p>
</section>
<section id="demo-2-perfectly-matched-layers">
<h3>Demo #2: Perfectly Matched Layers<a class="headerlink" href="#demo-2-perfectly-matched-layers" title="Permalink to this headline">#</a></h3>
<p>In the second demo, we show how to implement perfectly matched layers (shortly PMLs) for
the same problem solved in the first demo, i.e. the
scattering of a TM-polarized plane wave by an infinite gold wire. Perfectly
matched layers are artificial layers surrounding the domain that gradually absorb outgoing waves impinging on them, and are extensively used in time-harmonic electromagnetic
problems to solve the corresponding PDE within a finite domain. However, their mathematical implementation can
be quite tricky, and therefore showing the math and the corresponding DOLFINx
implementation is crucial for allowing users to quickly use FEniCSx to solve
photonic problems.</p>
<p>For this demo, we chose to use a square PML layer. In order to define PML equation, we
use a complex coordinate transformation of this kind in the PML domain:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; x^\prime= x\left\{1+j\frac{\alpha}{k_0}\left[\frac{|x|-l_{dom}/2}
{(l_{pml}/2 - l_{dom}/2)^2}\right] \right\}\\
&amp; y^\prime= y\left\{1+j\frac{\alpha}{k_0}\left[\frac{|y|-l_{dom}/2}
{(l_{pml}/2 - l_{dom}/2)^2}\right] \right\}\\
\end{align}
\end{split}\]</div>
<p>We then calculate the Jacobian associated with this transformation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{J}=\mathbf{A}^{-1}= \nabla\boldsymbol{x}^
\prime(\boldsymbol{x}) =
\left[\begin{array}{ccc}
\frac{\partial x^{\prime}}{\partial x} &amp;
\frac{\partial y^{\prime}}{\partial x} &amp;
\frac{\partial z^{\prime}}{\partial x} \\
\frac{\partial x^{\prime}}{\partial y} &amp;
\frac{\partial y^{\prime}}{\partial y} &amp;
\frac{\partial z^{\prime}}{\partial y} \\
\frac{\partial x^{\prime}}{\partial z} &amp;
\frac{\partial y^{\prime}}{\partial z} &amp;
\frac{\partial z^{\prime}}{\partial z}
\end{array}\right]=\left[\begin{array}{ccc}
\frac{\partial x^{\prime}}{\partial x} &amp; 0 &amp; 0 \\
0 &amp; \frac{\partial y^{\prime}}{\partial y} &amp; 0 \\
0 &amp; 0 &amp; \frac{\partial z^{\prime}}{\partial z}
\end{array}\right]=\left[\begin{array}{ccc}
J_{11} &amp; 0 &amp; 0 \\
0 &amp; J_{22} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]
\end{split}\]</div>
<p>Finally, we can express the complex coordinate transformation as a material
transformation within the PML, therefore having the following anisotropic,
inhomogeneous, and complex relative permittivity <span class="math notranslate nohighlight">\(\boldsymbol{\varepsilon}_{pml}\)</span> and permeability
<span class="math notranslate nohighlight">\(\boldsymbol{\mu}_{pml}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; {\boldsymbol{\varepsilon}_{pml}} =
\det(\mathbf{A}^{-1}) \mathbf{A} {\boldsymbol{\varepsilon}_b}\mathbf{A}^{T},\\
&amp; {\boldsymbol{\mu}_{pml}} =
\det(\mathbf{A}^{-1}) \mathbf{A} {\boldsymbol{\mu}_b}\mathbf{A}^{T},
\end{align}
\end{split}\]</div>
<p>All these steps have been defined in DOLFINx using the following functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
                    <span class="n">l_dom</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">x</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">algebra</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">create_eps_mu</span><span class="p">(</span><span class="n">pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="n">mu_bkg</span><span class="p">):</span>

    <span class="n">J</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">pml</span><span class="p">)</span>

    <span class="c1"># Transform the 2x2 Jacobian into a 3x3 matrix.</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">(((</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">eps_pml</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">eps_bkg</span> <span class="o">*</span> <span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">mu_pml</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">mu_bkg</span> <span class="o">*</span> <span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eps_pml</span><span class="p">,</span> <span class="n">mu_pml</span>

<span class="c1"># PML corners</span>
<span class="n">xy_pml</span> <span class="o">=</span> <span class="n">as_vector</span><span class="p">((</span><span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">),</span>
                    <span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">)))</span>

<span class="c1"># PML rectangles along x</span>
<span class="n">x_pml</span> <span class="o">=</span> <span class="n">as_vector</span><span class="p">((</span><span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1"># PML rectangles along y</span>
<span class="n">y_pml</span> <span class="o">=</span> <span class="n">as_vector</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">)))</span>

<span class="n">eps_x</span><span class="p">,</span> <span class="n">mu_x</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">x_pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">eps_y</span><span class="p">,</span> <span class="n">mu_y</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">y_pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">eps_xy</span><span class="p">,</span> <span class="n">mu_xy</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">xy_pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We need to define multiple coordinate transformation <code class="docutils literal notranslate"><span class="pre">xy_pml</span></code>, <code class="docutils literal notranslate"><span class="pre">x_pml</span></code> and <code class="docutils literal notranslate"><span class="pre">y_pml</span></code> since in the corners of the PML both coordinates are transformed, while in the rest of the PML just
one of them is. In the end, we can implement the weak form in DOLFINx in this way:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp;\int_{\Omega_{pml}}\left[\boldsymbol{\mu}^{-1}_{pml} \nabla \times \mathbf{E}
\right]\cdot \nabla \times \bar{\mathbf{v}}-k_{0}^{2}
\left[\boldsymbol{\varepsilon}_{pml} \mathbf{E} \right]\cdot
\bar{\mathbf{v}}~ d x  \\
+ &amp;\int_{\Omega_m\cup\Omega_b}-(\nabla \times \mathbf{E}_s)
\cdot (\nabla \times \bar{\mathbf{v}})+\varepsilon_{r} k_{0}^{2}
\mathbf{E}_s \cdot \bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}
-\varepsilon_b\right)\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d}x.
= 0.
\end{align}
\end{split}\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dDom</span> \
    <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">Es</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span> \
    <span class="o">+</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps</span> <span class="o">-</span> <span class="n">eps_bkg</span><span class="p">)</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">Eb</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span> \
    <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dPml_x</span> \
    <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dPml_y</span> \
    <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_xy</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dPml_xy</span> \
    <span class="o">+</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">eps_x</span> <span class="o">*</span> <span class="n">Es_3d</span><span class="p">,</span> <span class="n">v_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">dPml_x</span> \
    <span class="o">+</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">eps_y</span> <span class="o">*</span> <span class="n">Es_3d</span><span class="p">,</span> <span class="n">v_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">dPml_y</span> \
    <span class="o">+</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">eps_xy</span> <span class="o">*</span> <span class="n">Es_3d</span><span class="p">,</span> <span class="n">v_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">dPml_x</span>
</pre></div>
</div>
<p>Then, as in the first demo, we calculated the efficiencies and compared them with analytical ones. For scattering efficiencies, we needed to define
the integration domain slightly differently with respect to demo #1, since
we have to deal with an inner facet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">marker</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="n">scatt_facets</span> <span class="o">=</span> <span class="n">facet_tags</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">scatt_tag</span><span class="p">)</span>
<span class="n">incident_cells</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">compute_incident_entities</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">scatt_facets</span><span class="p">,</span>
                                                <span class="n">domain</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                <span class="n">domain</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

<span class="n">midpoints</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">compute_midpoints</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">incident_cells</span><span class="p">)</span>
<span class="n">inner_cells</span> <span class="o">=</span> <span class="n">incident_cells</span><span class="p">[(</span><span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                              <span class="o">+</span> <span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">l_scatt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>

<span class="n">marker</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">inner_cells</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Quantities for the calculation of efficiencies</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">Esh_3d</span><span class="p">,</span> <span class="n">conj</span><span class="p">(</span><span class="n">Hsh_3d</span><span class="p">)),</span> <span class="n">n_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">marker</span>

<span class="c1"># Define integration facet for the scattering efficiency</span>
<span class="n">dS</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;dS&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">facet_tags</span><span class="p">)</span>

<span class="c1"># Normalized scattering efficiency</span>
<span class="n">q_sca_fenics_proc</span> <span class="o">=</span> <span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span>
    <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">((</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span> <span class="o">*</span> <span class="n">dS</span><span class="p">(</span><span class="n">scatt_tag</span><span class="p">)))</span> <span class="o">/</span> <span class="n">gcs</span> <span class="o">/</span> <span class="n">I0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

</pre></div>
</div>
<p>As in the first demo, also in this case the error is smaller than <span class="math notranslate nohighlight">\(1\%\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">analytical</span> <span class="n">absorption</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.9089500187622276</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">absorption</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.9075812357239408</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.1505894724718481</span><span class="o">%</span>

<span class="n">The</span> <span class="n">analytical</span> <span class="n">scattering</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.8018061316558375</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">scattering</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.7996621815340356</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.2673900880970269</span><span class="o">%</span>

<span class="n">The</span> <span class="n">analytical</span> <span class="n">extinction</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">1.710756150418065</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">extinction</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">1.7072434172579762</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.2053321953120203</span><span class="o">%</span>
</pre></div>
</div>
<p>Here below, you can see the time-harmonic animation of the scattered
electric field norm obtained in DOLFINx and post-processed in Paraview:</p>
<p><img alt="pml" src="_images/animation_pml.gif" /></p>
</section>
<section id="demo-3-half-loaded-waveguide-with-slepc">
<h3>Demo #3: Half-loaded waveguide with SLEPc<a class="headerlink" href="#demo-3-half-loaded-waveguide-with-slepc" title="Permalink to this headline">#</a></h3>
<p>The third demo shows how to solve an eigenvalue electromagnetic problem
in DOLFINx with the SLEPc library. In particular, we solve the eigenvalue problem of a half-loaded electromagnetic waveguide with perfect
electric conducting walls (PEC conditions). The equations for our problem are the
Maxwell’s equation and the PEC equation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp;\nabla \times \frac{1}{\mu_{r}} \nabla \times \mathbf{E}-k_{0}^{2}
\epsilon_{r} \mathbf{E}=0 \quad &amp;\text { in } \Omega\\
&amp;\hat{n}\times\mathbf{E} = 0 &amp;\text { on } \Gamma
\end{align}
\end{split}\]</div>
<p>The final weak form can be found by considering a known <span class="math notranslate nohighlight">\(z\)</span> dependance of
the electric field:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{E}(x, y, z)=\left[\mathbf{E}_{t}(x, y)+\hat{z} E_{z}(x, y)\right]
e^{-jk_z z}
\]</div>
<p>and by using the following substitution:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \mathbf{e}_t = k_z\mathbf{E}_t\\
&amp; e_z = -jE_z
\end{align}
\end{split}\]</div>
<p>In the end, we get the following equation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
F_{k_z}(\mathbf{e})=\int_{\Omega} &amp;\left(\nabla_{t} \times
\mathbf{e}_{t}\right) \cdot\left(\nabla_{t} \times
\bar{\mathbf{v}}_{t}\right) -k_{o}^{2} \epsilon_{r} \mathbf{e}_{t} \cdot
\bar{\mathbf{v}}_{t} \\
&amp;+k_z^{2}\left[\left(\nabla_{t} e_{z}+\mathbf{e}_{t}\right)
\cdot\left(\nabla_{t} \bar{v}_{z}+\bar{\mathbf{v}}_{t}\right)-k_{o}^{2}
\epsilon_{r} e_{z} \bar{v}_{z}\right] \mathrm{d} x = 0
\end{aligned}
\end{split}\]</div>
<p>which we can write in a more compact form as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[\begin{array}{cc}
A_{t t} &amp; 0 \\
0 &amp; 0
\end{array}\right]\left\{\begin{array}{l}
\mathbf{e}_{t} \\
e_{z}
\end{array}\right\}=-k_z^{2}\left[\begin{array}{ll}
B_{t t} &amp; B_{t z} \\
B_{z t} &amp; B_{z z}
\end{array}\right]\left\{\begin{array}{l}
\mathbf{e}_{t} \\
e_{z}
\end{array}\right\}
\end{split}\]</div>
<p>A problem of this form is commonly known as a <em>generalized eigenvalue problem</em>, where the eigenvalue is <span class="math notranslate nohighlight">\(-k_z^2\)</span> and the eigenvector is <span class="math notranslate nohighlight">\(\mathbf{e}_t, e_z\)</span>.</p>
<p>The weak form in DOLFINx can be written in this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_tt</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">curl</span><span class="p">(</span><span class="n">et</span><span class="p">),</span> <span class="n">curl</span><span class="p">(</span><span class="n">vt</span><span class="p">))</span> <span class="o">-</span> <span class="n">k0</span>
        <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">vt</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">b_tt</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">vt</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">b_tz</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">vz</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">b_zt</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">ez</span><span class="p">),</span> <span class="n">vt</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">b_zz</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">ez</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">vz</span><span class="p">))</span> <span class="o">-</span> <span class="n">k0</span>
        <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">ez</span><span class="p">,</span> <span class="n">vz</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">a_tt</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">b_tt</span> <span class="o">+</span> <span class="n">b_tz</span> <span class="o">+</span> <span class="n">b_zt</span> <span class="o">+</span> <span class="n">b_zz</span><span class="p">)</span>
</pre></div>
</div>
<p>While for the perfect electric conductor condition we used these commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bc_facets</span> <span class="o">=</span> <span class="n">exterior_facet_indices</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">topology</span><span class="p">)</span>

<span class="n">bc_dofs</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">locate_dofs_topological</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bc_facets</span><span class="p">)</span>

<span class="n">u_bc</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">with</span> <span class="n">u_bc</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">localForm</span><span class="p">()</span> <span class="k">as</span> <span class="n">loc</span><span class="p">:</span>
    <span class="n">loc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">dirichletbc</span><span class="p">(</span><span class="n">u_bc</span><span class="p">,</span> <span class="n">bc_dofs</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we assembled the <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrices with PETSc:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span>
<span class="n">A</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span>
<span class="n">B</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
</pre></div>
</div>
<p>These matrices are the inputs SLEPc needs to solve our problem, as shown in the next snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span> <span class="o">=</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>

<span class="n">eps</span><span class="o">.</span><span class="n">setOperators</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we need to tweak some SLEPc settings, to guarantee the convergence of the solver, as shown below. For this problem, we need to use a spectral transformation to solve the problem, and getting our eigenvalue(s). In particular, spectral transformation techniques map the eigenvalues in other portion of the spectrum, to make the algorithm more efficient. We then need to set a target value for our eigenvalue, the number of eigenvalues we want to find, and we can finally solve the problem. It is worth highlighting that solving eigenvalue problems can be tricky, and therefore finding the correct eigenvalues of the problem may require a lot of tweaking. For this problem,
the following settings worked well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the tolerance for the solution</span>
<span class="n">eps</span><span class="o">.</span><span class="n">setTolerances</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

<span class="c1"># Set solver type</span>
<span class="n">eps</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">KRYLOVSCHUR</span><span class="p">)</span>

<span class="c1"># Set spectral transformation</span>
<span class="n">st</span> <span class="o">=</span> <span class="n">eps</span><span class="o">.</span><span class="n">getST</span><span class="p">()</span>
<span class="n">st</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">ST</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">SINVERT</span><span class="p">)</span>

<span class="c1"># Set type of target</span>
<span class="n">eps</span><span class="o">.</span><span class="n">setWhichEigenpairs</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Which</span><span class="o">.</span><span class="n">TARGET_REAL</span><span class="p">)</span>

<span class="c1"># Set target</span>
<span class="n">eps</span><span class="o">.</span><span class="n">setTarget</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">k0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Set number of eigenvalues</span>
<span class="n">eps</span><span class="o">.</span><span class="n">setDimensions</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Solve</span>
<span class="n">eps</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>We then get and save the solutions in this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">eps</span><span class="o">.</span><span class="n">getEigenvalue</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eps</span><span class="o">.</span><span class="n">getConverged</span><span class="p">())]</span>

<span class="n">vals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

<span class="n">eh</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">kz_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kz</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>

    <span class="c1"># Save eigenvector in eh</span>
    <span class="n">eps</span><span class="o">.</span><span class="n">getEigenpair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">eh</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="c1"># Compute error for i-th eigenvalue</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">eps</span><span class="o">.</span><span class="n">computeError</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">ErrorType</span><span class="o">.</span><span class="n">RELATIVE</span><span class="p">)</span>

    <span class="c1"># Verify, save and visualize solution</span>
    <span class="k">if</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">kz</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>

        <span class="n">kz_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kz</span><span class="p">)</span>

        <span class="c1"># Verify if kz satisfy the analytical equations for the modes</span>
        <span class="k">assert</span> <span class="n">verify_mode</span><span class="p">(</span><span class="n">kz</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">lmbd0</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eigenvalue: </span><span class="si">{</span><span class="o">-</span><span class="n">kz</span><span class="o">**</span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kz: </span><span class="si">{</span><span class="n">kz</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kz/k0: </span><span class="si">{</span><span class="n">kz</span><span class="o">/</span><span class="n">k0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">eh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>

        <span class="n">eth</span><span class="p">,</span> <span class="n">ezh</span> <span class="o">=</span> <span class="n">eh</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="c1"># Transform eth, ezh into Et and Ez</span>
        <span class="n">eth</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">/</span> <span class="n">kz</span>
        <span class="n">ezh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ezh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>

        <span class="n">V_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DQ&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>
        <span class="n">Et_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
        <span class="n">Et_dg</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">eth</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">VTXWriter</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sols/Et_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.bp&quot;</span><span class="p">,</span> <span class="n">Et_dg</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">VTXWriter</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sols/Ez_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.bp&quot;</span><span class="p">,</span> <span class="n">ezh</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>It is worth highlighting that we filtered out the solutions that do not
satisfy the tolerance requirements set in SLEPc, and that have a corresponding <span class="math notranslate nohighlight">\(k_z\)</span> with an imaginary
part different from zero, since we are only interested in propagating solutions (i.e. real <span class="math notranslate nohighlight">\(k_z\)</span>)</p>
<p>Then, we verify that our SLEPc solutions are consistent with the analytical formula for the half-loaded waveguide modes, which are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\textrm{For TE}_x \textrm{ modes}:
\begin{cases}
&amp;k_{x d}^{2}+\left(\frac{n \pi}{b}\right)^{2}+k_{z}^{2}=k_0^{2}
\varepsilon_{d} \\
&amp;k_{x v}^{2}+\left(\frac{n \pi}{b}\right)^{2}+k_{z}^{2}=k_0^{2}
\varepsilon_{v} \\
&amp; k_{x d} \cot k_{x d} d + k_{x v} \cot \left[k_{x v}(h-d)\right] = 0
\end{cases}
\end{aligned}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\textrm{For TM}_x \textrm{ modes}:
\begin{cases}
&amp;k_{x d}^{2}+\left(\frac{n \pi}{w}\right)^{2}+k_{z}^{2}=
k_0^{2} \varepsilon_{d} \\
&amp;k_{x v}^{2}+\left(\frac{n \pi}{w}\right)^{2}+k_{z}^{2}=
k_0^{2} \varepsilon_{v} \\
&amp; \frac{k_{x d}}{\varepsilon_{d}} \tan k_{x d} d +
\frac{k_{x v}}{\varepsilon_{v}} \tan \left[k_{x v}(h-d)\right] = 0
\end{cases}
\end{aligned}
\end{split}\]</div>
<p>The <code class="docutils literal notranslate"><span class="pre">analytical_modes.py</span></code> file defines these formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">TMx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">kx_d</span> <span class="o">/</span> <span class="n">eps_d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_d</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">kx_v</span> <span class="o">/</span> <span class="n">eps_v</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">d</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">TEx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">kx_d</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_d</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">kx_v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">d</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">verify_mode</span><span class="p">(</span>
        <span class="n">kz</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">lmbd0</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>

    <span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">lmbd0</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ky</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">w</span>

    <span class="n">kx_d_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps_d</span> <span class="o">-</span> <span class="n">ky</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="o">-</span> <span class="n">kz</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">kx_d_target</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">beta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">k0</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps_d</span> <span class="o">-</span> <span class="n">eps_v</span><span class="p">)</span>

    <span class="n">kx_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="n">kx_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

    <span class="n">f_tm</span> <span class="o">=</span> <span class="n">TMx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">f_te</span> <span class="o">=</span> <span class="n">TEx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">f_tm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">f_te</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">verify_mode</span></code> function takes a <span class="math notranslate nohighlight">\(k_z\)</span> value, finds the corresponding
<span class="math notranslate nohighlight">\(k_{xd}\)</span> and <span class="math notranslate nohighlight">\(k_{xv}\)</span>, and verify if for these values either the <span class="math notranslate nohighlight">\(\text{TM}_x\)</span> or
the <span class="math notranslate nohighlight">\(\text{TE}_x\)</span> equations are close to zero (within a certain range of confidence).
For the sake of simplicity, we just considered the fundamental mode for <span class="math notranslate nohighlight">\(k_y = n\pi/w = \pi/w\)</span>. For a more general approach, one should run this verification for multiple
harmonic numbers <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>In the end, we get the following eigenvalue, which successfully passes our test:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eigenvalue</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.6924040028250327</span><span class="o">+</span><span class="mf">1.3702668664033287e-14</span><span class="n">j</span><span class="p">)</span>
<span class="n">kz</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.3009242878911258</span><span class="o">-</span><span class="mf">5.266512736973384e-15</span><span class="n">j</span><span class="p">)</span>
<span class="n">kz</span><span class="o">/</span><span class="n">k0</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4658591947638973</span><span class="o">-</span><span class="mf">1.885930953627917e-15</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="demo-4-maxwells-equations-for-axisymmetric-geometries">
<h3>Demo #4: Maxwell’s equations for axisymmetric geometries<a class="headerlink" href="#demo-4-maxwells-equations-for-axisymmetric-geometries" title="Permalink to this headline">#</a></h3>
<p>The fourth demo shows how to solve Maxwell’s equations for a simple three-dimensional axisymmetric scattering structure, i.e. a sphere. Generally, solving three-dimensional electromagnetic problems is computationally expensive, and it may result in prohibitive memory and time requirements. However, if the three-dimensional geometry has an axisymmetry, the full wave problem can be decomposed in few two-dimensional problems, with an overall much lower computational cost.</p>
<p>We start from the weak form for Maxwell’s equations and PML equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp;\int_{\Omega_m\cup\Omega_b}-(\nabla \times \mathbf{E}_s)
\cdot (\nabla \times \bar{\mathbf{v}})+\varepsilon_{r} k_{0}^{2}
\mathbf{E}*s \cdot \bar{\mathbf{v}}+k*{0}^{2}\left(\varepsilon_{r}
-\varepsilon_b\right)\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d} x\\
+&amp;\int_{\Omega_{pml}}\left[\boldsymbol{\mu}^{-1}_{pml} \nabla \times \mathbf{E}_s
\right]\cdot \nabla \times \bar{\mathbf{v}}-k_{0}^{2}
\left[\boldsymbol{\varepsilon}_{pml} \mathbf{E}_s \right]\cdot
\bar{\mathbf{v}}~ d x=0
\end{align}
\end{split}\]</div>
<p>We then decompose the fields in cylindrical harmonics:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \mathbf{E}_s(\rho, z, \phi) = \sum_m\mathbf{E}^{(m)}_s(\rho, z)e^{-im\phi} \\
&amp; \mathbf{E}_b(\rho, z, \phi) = \sum_m\mathbf{E}^{(m)}_b(\rho, z)e^{-im\phi} \\
&amp; \bar{\mathbf{v}}(\rho, z, \phi) =
\sum_m\bar{\mathbf{v}}^{(m)}(\rho, z)e^{+im\phi}\\
\end{align}
\end{split}\]</div>
<p>and with few other steps (that we are going to skip here but are extensively explained in the demo) we arrive at the final weak form, showing 1) that the problem is formulated over a two-dimensional domain, and 2) that the different cylindrical harmonics propagate independently:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\sum_{m}\int_{\Omega_{cs}}&amp;-(\nabla \times \mathbf{E}^{(m)}_s)
\cdot (\nabla \times \bar{\mathbf{v}}^{(m)})+\varepsilon_{r} k_{0}^{2}
\mathbf{E}^{(m)}_s \cdot \bar{\mathbf{v}}^{(m)}
+k_{0}^{2}\left(\varepsilon_{r}
-\varepsilon_b\right)\mathbf{E}^{(m)}_b \cdot \bar{\mathbf{v}}^{(m)}\\
&amp;+\left(\boldsymbol{\mu}^{-1}_{pml} \nabla \times \mathbf{E}^{(m)}_s
\right)\cdot \nabla \times \bar{\mathbf{v}}^{(m)}-k_{0}^{2}
\left(\boldsymbol{\varepsilon}_{pml} \mathbf{E}^{(m)}_s \right)\cdot
\bar{\mathbf{v}}^{(m)}~ \rho d\rho dz =0
\end{align}
\end{split}\]</div>
<p>Therefore, the original problem can be solved for each cylindrical harmonic over a 2D cross-section of the original domain. For the sake of simplicity, we choose this cross-section to be the one at <span class="math notranslate nohighlight">\(\phi = 0\)</span>.</p>
<p>In the demo we present and implement a lot of concepts that we need for axisymmetric problems. We list them in the following sections.</p>
<section id="nabla-times-operator-in-cylindrical-coordinates">
<h4><span class="math notranslate nohighlight">\(\nabla\times\)</span> operator in cylindrical coordinates<a class="headerlink" href="#nabla-times-operator-in-cylindrical-coordinates" title="Permalink to this headline">#</a></h4>
<p>In cylindrical coordinates, the curl operator becomes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\left(\nabla \times \mathbf{a}^{(m)}\right) = &amp;\left[\hat{\rho}
\left(-\frac{\partial a_{\phi}^{(m)}}{\partial z}
-i \frac{m}{\rho} a_{z}^{(m)}\right)+\\ \hat{\phi}
\left(\frac{\partial a_{\rho}^{(m)}}{\partial z}
-\frac{\partial a_{z}^{(m)}}{\partial \rho}\right)+\right.\\
&amp;\left.+\hat{z}\left(\frac{a_{\phi}^{(m)}}{\rho}
+\frac{\partial a_{\phi}^{(m)}}{\partial \rho}
+i \frac{m}{\rho} a_{\rho}^{(m)}\right)\right]
\end{align}
\end{split}\]</div>
<p>The corresponding DOLFINx implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">curl_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>

    <span class="n">curl_r</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m</span> <span class="o">/</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">curl_z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m</span> <span class="o">/</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">curl_p</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">curl_r</span><span class="p">,</span> <span class="n">curl_z</span><span class="p">,</span> <span class="n">curl_p</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="cylindrical-harmonic-expansion-for-mathbf-e-m-b">
<h4>Cylindrical harmonic expansion for <span class="math notranslate nohighlight">\(\mathbf{E}^{(m)}_b\)</span><a class="headerlink" href="#cylindrical-harmonic-expansion-for-mathbf-e-m-b" title="Permalink to this headline">#</a></h4>
<p>The <span class="math notranslate nohighlight">\(m\)</span>-th harmonic for the background field can be expressed in terms of Bessel functions as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
\begin{align}
\mathbf{E}^{(m)}_b = &amp;\hat{\rho} \left(E_{0} \cos \theta
e^{i k z \cos \theta} i^{-m+1} J_{m}^{\prime}\left(k_{0} \rho \sin
\theta\right)\right)\\
+&amp;\hat{z} \left(E_{0} \sin \theta e^{i k z \cos \theta}i^{-m} J_{m}
\left(k \rho \sin \theta\right)\right)\\
+&amp;\hat{\phi} \left(\frac{E_{0} \cos \theta}{k \rho \sin \theta}
e^{i k z \cos \theta} i^{-m} J_{m}\left(k \rho \sin \theta\right)\right)
\end{align}
\end{split}
\end{split}\]</div>
<p>In DOLFINx, the corresponding implementation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">background_field_rz</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span>

    <span class="n">a_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
           <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">jvp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">a_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
           <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">**-</span><span class="n">m</span> <span class="o">*</span> <span class="n">jv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">a_r</span><span class="p">,</span> <span class="n">a_z</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">background_field_p</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span>

    <span class="n">a_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
           <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">*</span> <span class="n">m</span>
           <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">jv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">a_p</span>
</pre></div>
</div>
</section>
<section id="axisymmetric-pmls">
<h4>Axisymmetric PMLs<a class="headerlink" href="#axisymmetric-pmls" title="Permalink to this headline">#</a></h4>
<p>For axisymmetric structure, we need an axisymmetric complex coordinate transformation
for PML. One possible choice is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
\begin{align}
&amp; \rho^{\prime} = \rho\left[1 +j \alpha/k_0 \left(\frac{r
- r_{dom}}{r~r_{pml}}\right)\right] \\
&amp; z^{\prime} = z\left[1 +j \alpha/k_0 \left(\frac{r
- r_{dom}}{r~r_{pml}}\right)\right] \\
&amp; \phi^{\prime} = \phi \\
\end{align}
\end{split}
\end{split}\]</div>
<p>and the corresponding Jacobian is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
\mathbf{J}=\mathbf{A}^{-1}= \nabla\boldsymbol{\rho}^
\prime(\boldsymbol{\rho}) =
\left[\begin{array}{ccc}
\frac{\partial \rho^{\prime}}{\partial \rho} &amp;
\frac{\partial z^{\prime}}{\partial \rho} &amp;
0 \\
\frac{\partial \rho^{\prime}}{\partial z} &amp;
\frac{\partial z^{\prime}}{\partial z} &amp;
0 \\
0 &amp;
0 &amp;
\frac{\rho^\prime}{\rho}\frac{\partial \phi^{\prime}}{\partial \phi}
\end{array}\right]=\left[\begin{array}{ccc}
J_{11} &amp; J_{12} &amp; 0 \\
J_{21} &amp; J_{22} &amp; 0 \\
0 &amp; 0 &amp; J_{33}
\end{array}\right]
\end{split}
\end{split}\]</div>
<p>In DOLFINx, similarly to what we did for demo #2, we can define these functions
as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pml_coordinate</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radius_dom</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radius_pml</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">radius_dom</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">radius_pml</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">create_eps_mu</span><span class="p">(</span><span class="n">pml</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="n">mu_bkg</span><span class="p">):</span>

    <span class="n">J</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">pml</span><span class="p">)</span>

    <span class="c1"># Transform the 2x2 Jacobian into a 3x3 matrix.</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(((</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                       <span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                       <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pml</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">rho</span><span class="p">)))</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">eps_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">eps_bkg</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">mu_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">mu_bkg</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eps_pml</span><span class="p">,</span> <span class="n">mu_pml</span>

<span class="n">rho</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">pml_coords</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span>
    <span class="n">pml_coordinate</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">radius_dom</span><span class="p">,</span> <span class="n">radius_pml</span><span class="p">),</span>
    <span class="n">pml_coordinate</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">radius_dom</span><span class="p">,</span> <span class="n">radius_pml</span><span class="p">)))</span>

<span class="n">eps_pml</span><span class="p">,</span> <span class="n">mu_pml</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">pml_coords</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

</pre></div>
</div>
</section>
<section id="solving-the-problem">
<h4>Solving the problem<a class="headerlink" href="#solving-the-problem" title="Permalink to this headline">#</a></h4>
<p>In DOLFINx, we need to solve as many weak form as the harmonic numbers <span class="math notranslate nohighlight">\(m\in \mathbb{Z}\)</span>. Thanks to Bessel functions parities,
we can only solve for <span class="math notranslate nohighlight">\(m\geq0\)</span>, and adding a <span class="math notranslate nohighlight">\(2\)</span> factor to solutions for <span class="math notranslate nohighlight">\(m\geq1\)</span>.
But… where do we stop the expansion? Theoretically, the expansion in cylindrical
harmonics has infinite terms, and it goes without saying that we cannot
consider all of them. However, a good rule of thumb is that for deeply sub-wavelength particles, as in our case, few cylindrical harmonics (e.g. <span class="math notranslate nohighlight">\(m = 0, 1\)</span>) are usually enough to reach a good accuracy. The bigger the particle, the bigger the expansion,
since we need more cylindrical harmonics to construct a plane wave in bigger domains.</p>
<p>Finally, the problem can be solved in DOLFINx with a loop over the <span class="math notranslate nohighlight">\(m\)</span> in the
following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_list</span><span class="p">:</span>

    <span class="c1"># Definition of Trial and Test functions</span>
    <span class="n">Es_m</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v_m</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="c1"># Background field</span>
    <span class="n">Eb_m</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">f_rz</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">background_field_rz</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">f_p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">background_field_p</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">Eb_m</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f_rz</span><span class="p">)</span>
    <span class="n">Eb_m</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f_p</span><span class="p">)</span>

    <span class="n">curl_Es_m</span> <span class="o">=</span> <span class="n">curl_axis</span><span class="p">(</span><span class="n">Es_m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
    <span class="n">curl_v_m</span> <span class="o">=</span> <span class="n">curl_axis</span><span class="p">(</span><span class="n">v_m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>

    <span class="n">F</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">curl_Es_m</span><span class="p">,</span> <span class="n">curl_v_m</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">dDom</span> \
        <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Es_m</span><span class="p">,</span> <span class="n">v_m</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">dDom</span> \
        <span class="o">+</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps</span> <span class="o">-</span> <span class="n">eps_bkg</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Eb_m</span><span class="p">,</span> <span class="n">v_m</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">dDom</span> \
        <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_pml</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_Es_m</span><span class="p">,</span> <span class="n">curl_v_m</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">dPml</span> \
        <span class="o">+</span> <span class="n">k0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">eps_pml</span> <span class="o">*</span> <span class="n">Es_m</span><span class="p">,</span> <span class="n">v_m</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">dPml</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

    <span class="n">problem</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">LinearProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[],</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span>
                                      <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">})</span>
    <span class="n">Esh_m</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">Esh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Esh_m</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="n">m_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

        <span class="n">Esh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Esh_m</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">Esh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Esh_m</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="test">
<h4>Test<a class="headerlink" href="#test" title="Permalink to this headline">#</a></h4>
<p>The DOLFINx solution was tested by calculating the numerical efficiencies and
comparing them with the analytical efficiencies. The analytical efficiencies were
calculated with the <a class="reference external" href="https://github.com/ovidiopr/scattnlay">scattnlay</a> library,
with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scattnlay</span> <span class="kn">import</span> <span class="n">scattnlay</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eps_au</span><span class="p">)</span><span class="o">/</span><span class="n">n_bkg</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">radius_sph</span><span class="o">/</span><span class="n">wl0</span><span class="o">*</span><span class="n">n_bkg</span>

<span class="n">q_ext</span><span class="p">,</span> <span class="n">q_sca</span><span class="p">,</span> <span class="n">q_abs</span> <span class="o">=</span> <span class="n">scattnlay</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">))[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>The procedure for numerical efficiencies is similar to what we already did in
demo #2, with the only difference that we need to add a <span class="math notranslate nohighlight">\(2\)</span> factor for the
efficiencies resulting from <span class="math notranslate nohighlight">\(m\geq1\)</span> harmonics.</p>
<p>The comparison between analytical and numerical results shows an error well below <span class="math notranslate nohighlight">\(1\%\)</span>, and therefore we can safely say that the problem in DOLFINx is well
set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">analytical</span> <span class="n">absorption</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.9622728008329892</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">absorption</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.9583126377885698</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.41154265619804153</span><span class="o">%</span>

<span class="n">The</span> <span class="n">analytical</span> <span class="n">scattering</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.07770397394691526</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">scattering</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">0.07737655859424392</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.4213624297967401</span><span class="o">%</span>

<span class="n">The</span> <span class="n">analytical</span> <span class="n">extinction</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">1.0399767747799045</span>
<span class="n">The</span> <span class="n">numerical</span> <span class="n">extinction</span> <span class="n">efficiency</span> <span class="ow">is</span> <span class="mf">1.0356891963828136</span>
<span class="n">The</span> <span class="n">error</span> <span class="ow">is</span> <span class="mf">0.4122763604983602</span><span class="o">%</span>
</pre></div>
</div>
<p>As a final example, here below we show the magnitude of the real part of the (total)
scattered field:</p>
<p><img alt="axis" src="_images/axis.png" /></p>
</section>
</section>
</section>
<section id="challenges-and-final-remarks">
<h2>Challenges and final remarks<a class="headerlink" href="#challenges-and-final-remarks" title="Permalink to this headline">#</a></h2>
<p>The most challenging aspect of GSoC was dealing with unexpected results and
troubleshooting. Indeed, debugging was one of the most important skill I needed to improve during GSoC, since it never happened to run a demo at the first try without problems, and therefore I needed to quickly understand how to approach
and solve these situations.</p>
<p>For all demos I needed quite a lot of time just for debugging purposes, but for demo #4 this time was much higher. Indeed, I had to deal with an unexpected behavior of the demo:
whenever I used discretization elements with <code class="docutils literal notranslate"><span class="pre">degree</span> <span class="pre">=</span> <span class="pre">3</span></code> (or higher), the error for the efficiencies unexpectedly increased, and the corresponding DOLFINx solutions had some nasty artifacts, as shown in
the image below.</p>
<p><img alt="error" src="_images/error.png" /></p>
<p>In order to understand the error, I tried to isolate the problem and collect as much
information as possible. The first thing that came to my mind was a bug in the
functions I wrote for the demo. Therefore I substituted PML with scattering
boundary conditions, and verified if the background field showed the same artifacts
of the output field. However, scattering boundary conditions did not change the
output (high errors, same nasty artifacts), and the background field had no strange
behavior, and was consistent with the background field I implemented
for the same problem in legacy DOLFIN (extensively tested up to <code class="docutils literal notranslate"><span class="pre">degree</span> <span class="pre">=</span> <span class="pre">5</span></code>). Therefore, I was reasonably sure that PML and
the background field were implemented correctly. What I tried to do next was
comparing my legacy DOLFIN demo with my new DOLFINx demo for different
harmonic numbers. What I noticed was that for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">0</span></code> the outputs for both demos had the
same efficiencies whatever the degree, while these efficiencies diverged for
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">1</span></code>. Therefore, something happened when passing from <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">0</span></code> and
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">1</span></code>. The only two Python objects affected by the harmonic numbers were the
<code class="docutils literal notranslate"><span class="pre">background_field_rz</span></code>, <code class="docutils literal notranslate"><span class="pre">background_field_p</span></code>, and the <code class="docutils literal notranslate"><span class="pre">curl_axis</span></code> functions. As
already said, the background field functions were doing their job correctly, and
it was then clear that something wrong was happening within <code class="docutils literal notranslate"><span class="pre">curl_axis</span></code>, and
in particular for the terms activated by <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">1</span></code>. Since the mathematical
implementation of <code class="docutils literal notranslate"><span class="pre">curl_axis</span></code> was correct, the problem
was clearly something wrong in the DOLFINx codebase, and together with my
mentors I decided to open <a class="reference external" href="https://github.com/FEniCS/dolfinx/issues/2343">a GitHub issue</a> and to “pass the ball” to more
experienced developers. It turned out that there was a bug in the permutation
inside <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code>, solved by <a class="reference external" href="https://github.com/FEniCS/dolfinx/pull/2347">PR #2347</a>.</p>
<p>When dealing with these issues, it was particularly important to not get frustrated,
and to have built a strong communication with my mentors. Therefore, my suggestions for new
GSoC contributors are: 1) do not work on an issue if you are too much tired, rather take
some time off and try again after few hours or the next day, and 2) ask for help if
you are running out of ideas!</p>
<p>In the end, the GSoC has been the best professional experience of my life, since I have
learned
so much in 12 weeks that I can hardly recall everything. Just to name a few: I have learned how to run and manage Docker containers, I have a deeper knowledge of the
FEniCSx environment, I can now run and build static websites as the one you are reading now, I have a deeper understanding of how a big project as FEniCSx is managed, and I have
gained much more confidence in using git and GitHub tools.</p>
<p>My only regret is that I have not been too much active on the <a class="reference external" href="https://fenicsproject.discourse.group/">FEniCS discourse group</a>
for helping other users, mainly because answering many of the posted questions require a deep
technical knowledge about the FEniCSx environment that I have not gained yet. However,
I have also understood that solving other users’ problems is a great way to better understand FEniCSx, and therefore I will be for sure more active in the future.</p>
<p>Last but not least, I would like to thank my mentors Jørgen S. Dokken, Igor Baratta and Jack S. Hale for their patience and help over the 12 weeks. Discussing and working with them has been great since the beginning, and I could not have wished for a better
mentors/mentee relationship. I would also like to thank my supervisor Cristian
Ciracì, which introduced me to FEniCS and which helped me so much when solving
the problems I show in the demo.</p>
<p>And, if you arrived here, I would like to thank you too for reading about this
amazing journey!</p>
</section>
<section id="contacts">
<h2>Contacts<a class="headerlink" href="#contacts" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Michele Castriotta</p>
<ul>
<li><p><i class="fab fa-github"></i> <a class="reference external" href="https://github.com/mikics">mikics</a></p></li>
<li><p><i class="fab fa-twitter"></i> <a class="reference external" href="https://twitter.com/castrimik">&#64;castrimik</a></p></li>
<li><p><i class="fab fa-discourse"></i> <a class="reference external" href="https://fenicsproject.discourse.group/u/CastriMik">CastriMik</a></p></li>
<li><p><i class="fab fa-linkedin"></i> <a class="reference external" href="https://www.linkedin.com/in/michele-castriotta-18aa91a5">Michele Castriotta</a></p></li>
<li><p><i class="fa fa-envelope"></i> <a class="reference external" href="mailto:mich&#46;castriotta&#37;&#52;&#48;gmail&#46;com">mich<span>&#46;</span>castriotta<span>&#64;</span>gmail<span>&#46;</span>com</a></p></li>
</ul>
</li>
</ul>
</section>
<section id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">#</a></h2>
<div class="toctree-wrapper compound">
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Scattering boundary conditions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="chapter1/demo_scattering_boundary_conditions.html">Scattering from a wire with scattering boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter1/analytical_efficiencies_wire.html">Calculation of analytical efficiencies</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Perfectly matched layer (PML)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="chapter2/demo_pml.html">Scattering from a wire with perfectly matched layer condition</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter2/analytical_efficiencies_wire.html">Calculation of analytical efficiencies</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Half-loaded waveguide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="chapter3/demo_half_loaded_waveguide.html">Mode analysis for a half-loaded rectangular waveguide</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter3/analytical_modes.html">Analytical solutions for the half-loaded waveguide</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Axisymmetric Maxwell's equations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="chapter4/demo_axis.html">Scattering from a sphere in the axisymmetric formulation</a></li>
</ul>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='right-next' id="next-link" href="chapter1/demo_scattering_boundary_conditions.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Scattering from a wire with scattering boundary conditions</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Michele Castriotta<br/>
  
      &copy; Copyright 2022.<br/>
    <div class="extra_footer">
      <div>
    This webpage is an adaptation of <a href=https://jorgensd.github.io/fenics22-tutorial/intro.html>The FEniCSx tutorial for FEniCS 2022</a> and
    is distributed under the terms of the      <a href=http://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License  </a>
    which permits use, duplication, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source,
    provide a link to the Creative Commons license and indicate if changes were made.
</div>

    </div>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>